import Foundation
import FoundationDB

// MARK: - PrimaryKeyValue Type Alias

/// Type-erased primary key value
///
/// This associatedtype allows each Recordable type to specify its primary key type.
/// For backward compatibility, it defaults to Tuple.
public typealias DefaultPrimaryKeyValue = Tuple

// MARK: - Recordable Protocol

/// Protocol representing a type that can be persisted as a record
///
/// All record types must conform to this protocol.
/// Typically, the `@Recordable` macro automatically generates conformance to this protocol.
///
/// **Usage Example**:
/// ```swift
/// @Recordable
/// struct User {
///     @PrimaryKey var userID: Int64
///     var email: String
///     var name: String
/// }
/// ```
///
/// **After Macro Expansion**:
/// ```swift
/// extension User: Recordable {
///     static var recordName: String { "User" }
///     static var primaryKeyFields: [String] { ["userID"] }
///     static var allFields: [String] { ["userID", "email", "name"] }
///     // ... other method implementations
/// }
/// ```
public protocol Recordable: Sendable, Codable {
    /// Associated type for primary key value
    ///
    /// Defaults to Tuple for backward compatibility.
    /// Override with a specific PrimaryKeyProtocol type for type safety.
    associatedtype PrimaryKeyValue: PrimaryKeyProtocol = Tuple

    /// Record type name (identifier in metadata)
    ///
    /// A name to uniquely identify each record type.
    /// Usually the same as the type name, but can be changed if needed.
    ///
    /// **Examples**: `"User"`, `"Order"`, `"Product"`
    static var recordName: String { get }

    /// List of primary key fields
    ///
    /// A list of field names that constitute the record's primary key.
    /// Can specify a single field or multiple fields (composite primary key).
    ///
    /// **Examples**:
    /// - Single primary key: `["userID"]`
    /// - Composite primary key: `["tenantID", "userID"]`
    static var primaryKeyFields: [String] { get }

    // MARK: - New Type-Safe Primary Key API

    /// Type-safe primary key definition using KeyPaths
    ///
    /// This is the new API for defining primary keys with compile-time safety.
    /// If implemented, it will be used instead of `primaryKeyFields` for:
    /// - Schema definition (Entity.primaryKeyExpression)
    /// - Primary key extraction (via primaryKeyValue)
    ///
    /// **Single field example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<User, String>? {
    ///     PrimaryKeyPaths(keyPath: \.userID, fieldName: "userID")
    /// }
    /// ```
    ///
    /// **Composite key example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<Order, Order.PrimaryKey>? {
    ///     PrimaryKeyPaths(
    ///         extract: { Order.PrimaryKey(tenantID: $0.tenantID, orderID: $0.orderID) },
    ///         fieldNames: ["tenantID", "orderID"]
    ///     )
    /// }
    /// ```
    static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? { get }

    /// Type-safe primary key value
    ///
    /// This property extracts the primary key value using the type specified in
    /// `PrimaryKeyValue` associatedtype. It provides compile-time guarantees that
    /// the extracted value matches the expected type.
    ///
    /// **Example**:
    /// ```swift
    /// var primaryKeyValue: String? { userID }
    /// ```
    var primaryKeyValue: PrimaryKeyValue? { get }

    /// List of all field names (excluding @Transient)
    ///
    /// Names of all fields that will be persisted.
    /// Fields marked with `@Transient` are not included.
    ///
    /// **Example**: `["userID", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index definitions declared with #Index or #Unique macros
    ///
    /// This property should be automatically generated by @Recordable macro
    /// to collect all IndexDefinition static properties declared with #Index/#Unique.
    ///
    /// **Example (generated by macro)**:
    /// ```swift
    /// static var indexDefinitions: [IndexDefinition] {
    ///     [email_index, city__state_index]
    /// }
    /// ```
    ///
    /// If the type doesn't use #Index/#Unique macros, it returns an empty array.
    static var indexDefinitions: [IndexDefinition] { get }

    /// Mapping from field name to Protobuf field number
    ///
    /// Returns the field number used during Protobuf serialization.
    /// Field numbers are automatically assigned based on declaration order (starting from 1).
    ///
    /// - Parameter fieldName: Field name
    /// - Returns: Field number (starting from 1), or nil if not found
    static func fieldNumber(for fieldName: String) -> Int?

    /// Extract the value of a specified field (for indexing)
    ///
    /// Used during index construction.
    /// Returns the value corresponding to the field name as an array of `TupleElement`.
    ///
    /// **Examples**:
    /// ```swift
    /// user.extractField("email")  // -> ["alice@example.com"]
    /// user.extractField("tags")   // -> ["swift", "ios", "development"]
    /// ```
    ///
    /// - Parameter fieldName: Field name
    /// - Returns: Array of field values (multiple elements for array-type fields)
    func extractField(_ fieldName: String) -> [any TupleElement]

    /// Extract primary key as Tuple
    ///
    /// Returns the record's primary key in FoundationDB Tuple format.
    /// For a single primary key, it's a 1-element Tuple; for composite keys, it's a multi-element Tuple.
    ///
    /// **Examples**:
    /// ```swift
    /// user.extractPrimaryKey()  // -> Tuple(123)
    /// order.extractPrimaryKey() // -> Tuple("tenant_a", 456)  // Composite key
    /// ```
    ///
    /// - Returns: Primary key Tuple
    func extractPrimaryKey() -> Tuple

    /// Reconstruct a record from covering index key and value
    ///
    /// This method is used by covering indexes to rebuild records without
    /// fetching from storage. The @Recordable macro automatically generates
    /// this implementation.
    ///
    /// **Index key structure**: `<indexSubspace><rootExpression fields><primaryKey fields>`
    /// **Index value structure**: Tuple-packed covering field values
    ///
    /// **Field Assembly Strategy**:
    /// 1. Extract indexed fields from index key (via index.rootExpression)
    /// 2. Extract primary key from index key (last N elements)
    /// 3. Extract covering fields from index value (via index.coveringFields)
    /// 4. Reconstruct record with all available fields
    ///
    /// **Auto-Generated Example** (by @Recordable macro):
    /// ```swift
    /// // User: { userID (PK), city (indexed), name (covering), email (covering) }
    /// static func reconstruct(
    ///     indexKey: Tuple,
    ///     indexValue: FDB.Bytes,
    ///     index: Index,
    ///     primaryKeyExpression: KeyExpression
    /// ) throws -> User {
    ///     let rootCount = index.rootExpression.columnCount  // 1 (city)
    ///     let pkCount = primaryKeyExpression.columnCount    // 1 (userID)
    ///
    ///     // Extract indexed field: city
    ///     guard let city = indexKey[0] as? String else {
    ///         throw RecordLayerError.reconstructionFailed(
    ///             recordType: "User",
    ///             reason: "Invalid city field"
    ///         )
    ///     }
    ///
    ///     // Extract primary key: userID (last N elements)
    ///     guard let userID = indexKey[rootCount] as? Int64 else {
    ///         throw RecordLayerError.reconstructionFailed(
    ///             recordType: "User",
    ///             reason: "Invalid userID field"
    ///         )
    ///     }
    ///
    ///     // Extract covering fields: name, email
    ///     let coveringTuple = try Tuple.unpack(from: indexValue)
    ///     guard let name = coveringTuple[0] as? String,
    ///           let email = coveringTuple[1] as? String else {
    ///         throw RecordLayerError.reconstructionFailed(
    ///             recordType: "User",
    ///             reason: "Invalid covering fields"
    ///         )
    ///     }
    ///
    ///     return User(userID: userID, city: city, name: name, email: email)
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - indexKey: Index key (unpacked tuple)
    ///   - indexValue: Index value (packed covering fields)
    ///   - index: Index definition
    ///   - primaryKeyExpression: Primary key expression for field extraction
    /// - Returns: Reconstructed record
    /// - Throws: RecordLayerError.reconstructionFailed if reconstruction fails
    static func reconstruct(
        indexKey: Tuple,
        indexValue: FDB.Bytes,
        index: Index,
        primaryKeyExpression: KeyExpression
    ) throws -> Self

    /// Indicates whether this type supports covering index reconstruction
    ///
    /// Returns `true` if the type implements `reconstruct()` method properly.
    /// This allows the query planner to safely use covering index optimization.
    ///
    /// **Default**: `false` (safe, conservative)
    ///
    /// **Auto-Generated**: `@Recordable` macro sets this to `true`
    ///
    /// **Manual Implementation**: Override to return `true` if you manually
    /// implement `reconstruct()` method.
    ///
    /// - Returns: `true` if reconstruction is supported, `false` otherwise
    static var supportsReconstruction: Bool { get }

    // MARK: - Validation (for @Vector and @Spatial indexes)

    /// Validate fields with @Vector attributes
    ///
    /// This method is automatically generated by @Recordable macro when the record type
    /// contains fields with @Vector attributes. It validates that:
    /// - Fields conform to VectorRepresentable protocol
    /// - Vector dimensions match the expected dimensions from @Vector macro
    /// - toFloatArray() method can be called successfully
    ///
    /// **Auto-Generated Example**:
    /// ```swift
    /// func validateVectorFields() throws {
    ///     guard let vectorField = embedding as? any VectorRepresentable else {
    ///         throw RecordLayerError.invalidArgument(
    ///             "Field 'embedding' with @Vector attribute must conform to VectorRepresentable"
    ///         )
    ///     }
    ///     guard vectorField.dimensions == 768 else {
    ///         throw RecordLayerError.invalidArgument(
    ///             "Field 'embedding' dimension mismatch: expected 768, got \(vectorField.dimensions)"
    ///         )
    ///     }
    /// }
    /// ```
    ///
    /// **Default Implementation**: No-op (for types without @Vector fields)
    ///
    /// - Throws: RecordLayerError.invalidArgument if validation fails
    func validateVectorFields() throws

    /// Validate fields with @Spatial attributes
    ///
    /// This method is automatically generated by @Recordable macro when the record type
    /// contains fields with @Spatial attributes. It validates that:
    /// - Fields conform to SpatialRepresentable protocol
    /// - Coordinates are within valid ranges
    /// - toNormalizedCoordinates() method can be called successfully
    ///
    /// **Auto-Generated Example**:
    /// ```swift
    /// func validateSpatialFields() throws {
    ///     guard let spatialField = location as? any SpatialRepresentable else {
    ///         throw RecordLayerError.invalidArgument(
    ///             "Field 'location' with @Spatial attribute must conform to SpatialRepresentable"
    ///         )
    ///     }
    ///     // Validate 3D coordinates if includeAltitude=true
    ///     let coords = spatialField.toNormalizedCoordinates(altitudeRange: 0...5000)
    ///     guard coords.count == 3 else {
    ///         throw RecordLayerError.invalidArgument(
    ///             "Field 'location' with includeAltitude=true must provide 3D coordinates"
    ///         )
    ///     }
    /// }
    /// ```
    ///
    /// **Default Implementation**: No-op (for types without @Spatial fields)
    ///
    /// - Throws: RecordLayerError.invalidArgument if validation fails
    func validateSpatialFields() throws

    /// Extract Range boundary value (auto-generated by @Recordable macro)
    ///
    /// This static method is automatically generated by @Recordable macro for each
    /// Range-type field. It extracts the lowerBound or upperBound from the Range field
    /// without using Reflection, providing type-safe, compile-time boundary extraction.
    ///
    /// **Key Features**:
    /// - Handles Optional unwrapping at compile time (returns [] if nil)
    /// - Converts Date boundaries to Double (timeIntervalSince1970) automatically
    /// - Validates partial range boundary requests (e.g., PartialRangeFrom only has lowerBound)
    /// - Zero Reflection overhead (all logic generated at compile time)
    ///
    /// **Auto-Generated Example**:
    /// ```swift
    /// // For: var period: Range<Date>?
    /// static func extractRangeBoundary(
    ///     fieldName: String,
    ///     component: RangeComponent,
    ///     from record: any Recordable
    /// ) throws -> [any TupleElement] {
    ///     switch (fieldName, component) {
    ///     case ("period", .lowerBound):
    ///         guard let range = (record as! Event).period else { return [] }
    ///         return [(range.lowerBound as Date).timeIntervalSince1970]
    ///     case ("period", .upperBound):
    ///         guard let range = (record as! Event).period else { return [] }
    ///         return [(range.upperBound as Date).timeIntervalSince1970]
    ///     default:
    ///         throw RecordLayerError.fieldNotFound(fieldName)
    ///     }
    /// }
    /// ```
    ///
    /// **Design**: Prefers macro-generated code over Reflection
    /// 1. RecordAccess checks if Record conforms to Recordable
    /// 2. If yes, calls this static method (compile-time type-safe)
    /// 3. If no, falls back to Reflection (backward compatibility)
    ///
    /// - Parameters:
    ///   - fieldName: Range field name
    ///   - component: Boundary component (.lowerBound or .upperBound)
    ///   - record: Record instance (cast to specific type internally)
    /// - Returns: Array with boundary value as TupleElement (empty if nil Optional)
    /// - Throws: RecordLayerError.fieldNotFound if field doesn't exist or is not a Range
    static func extractRangeBoundary(
        fieldName: String,
        component: RangeComponent,
        from record: any Recordable
    ) throws -> [any TupleElement]
}

// MARK: - Helper Extensions

extension Recordable {
    /// Get field name from KeyPath
    ///
    /// **Note**: This implementation is overridden by macros for each type.
    /// The default implementation is a placeholder to prevent compilation errors.
    ///
    /// - Parameter keyPath: KeyPath to the field
    /// - Returns: Field name
    public static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        // This implementation is replaced by macros
        // By default, inferred from KeyPath string representation (with limitations)
        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }

    /// Convert PartialKeyPath to field name string
    ///
    /// This method is used by IndexDefinition to convert KeyPaths to field names.
    public static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        // Try to find a match using the generated fieldName<Value> method
        // by iterating through all fields
        // This is a fallback - the macro-generated implementation is more efficient

        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }
}

// MARK: - Default Implementations (Backward Compatibility)

extension Recordable {
    /// Default implementation: No index definitions
    ///
    /// Types without #Index/#Unique macros return an empty array.
    /// @Recordable macro will override this with actual index definitions.
    public static var indexDefinitions: [IndexDefinition] {
        return []
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, Entity.init() will fall back to building the primary key
    /// expression from `primaryKeyFields`.
    ///
    /// **Migration Path**:
    /// 1. Old API: `primaryKeyFields` + `extractPrimaryKey()` (current)
    /// 2. New API: `primaryKeyPaths` + `primaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? {
        return nil
    }

    /// Default implementation: Covering index reconstruction not supported
    ///
    /// Returns `false` by default to ensure safe behavior for types without
    /// proper `reconstruct()` implementation.
    ///
    /// **Override**: `@Recordable` macro sets this to `true` automatically.
    ///
    /// **Manual Implementation**: Return `true` if you manually implement
    /// `reconstruct()` method.
    public static var supportsReconstruction: Bool {
        return false
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, primary key extraction will use `extractPrimaryKey()` instead.
    ///
    /// **Migration Path**:
    /// 1. Old API: `extractPrimaryKey() -> Tuple` (current)
    /// 2. New API: `primaryKeyValue -> PrimaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public var primaryKeyValue: PrimaryKeyValue? {
        return nil
    }

    /// Get enum metadata for a field
    ///
    /// Returns enum type information if the field is a CaseIterable enum.
    /// This method is typically overridden by @Recordable macro for types with enum fields.
    ///
    /// **Default Implementation**:
    /// Returns nil for all fields (no enum metadata available).
    /// @Recordable macro will generate a switch statement that returns metadata
    /// for each enum field.
    ///
    /// **Example (macro-generated)**:
    /// ```swift
    /// static func enumMetadata(for fieldName: String) -> Schema.EnumMetadata? {
    ///     switch fieldName {
    ///     case "status":
    ///         return Schema.EnumMetadata(
    ///             typeName: "ProductStatus",
    ///             cases: ["active", "inactive", "discontinued"]
    ///         )
    ///     default:
    ///         return nil
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter fieldName: Field name to query
    /// - Returns: EnumMetadata if field is a CaseIterable enum, nil otherwise
    public static func enumMetadata(for fieldName: String) -> Schema.EnumMetadata? {
        return nil
    }

    /// Default implementation: Throw not implemented error
    ///
    /// This default implementation allows backward compatibility with existing code
    /// that doesn't use covering indexes. The @Recordable macro will override this
    /// with a proper implementation.
    ///
    /// **Migration Path**:
    /// 1. Old code without covering indexes → Uses default (throws error if used)
    /// 2. New code with @Recordable macro → Auto-generated reconstruct() implementation
    ///
    /// - Parameters:
    ///   - indexKey: Index key (unpacked tuple)
    ///   - indexValue: Index value (packed covering fields)
    ///   - index: Index definition
    ///   - primaryKeyExpression: Primary key expression
    /// - Returns: Reconstructed record
    /// - Throws: RecordLayerError.reconstructionNotImplemented by default
    public static func reconstruct(
        indexKey: Tuple,
        indexValue: FDB.Bytes,
        index: Index,
        primaryKeyExpression: KeyExpression
    ) throws -> Self {
        throw RecordLayerError.reconstructionNotImplemented(
            recordType: String(describing: Self.self),
            suggestion: """
            To use covering indexes with this record type, the @Recordable macro
            must generate a reconstruct() implementation. Make sure you are using
            the latest version of the @Recordable macro.
            """
        )
    }
}

// MARK: - Safe Derivation from New API

extension Recordable where PrimaryKeyValue: PrimaryKeyProtocol {
    /// Safely derive primaryKeyFields from primaryKeyPaths
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement primaryKeyFields.
    public static var derivedPrimaryKeyFields: [String] {
        if let paths = primaryKeyPaths {
            return paths.fieldNames
        }
        // Fallback: This should never be called if type implements primaryKeyFields
        fatalError("""
            Type \(Self.self) must implement either:
            1. primaryKeyFields (old API), or
            2. primaryKeyPaths (new API)
            """)
    }

    /// Safely derive extractPrimaryKey from primaryKeyValue
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement extractPrimaryKey().
    public func derivedExtractPrimaryKey() -> Tuple {
        if let value = primaryKeyValue {
            return value.toTuple()
        }
        // Fallback: This should never be called if type implements extractPrimaryKey()
        fatalError("""
            Type \(Self.self) must implement either:
            1. extractPrimaryKey() (old API), or
            2. primaryKeyValue (new API)
            """)
    }

    // MARK: - Validation Default Implementations

    /// Default implementation: No-op for types without @Vector fields
    ///
    /// Types with @Vector attributes will have this method auto-generated
    /// by @Recordable macro with actual validation logic.
    public func validateVectorFields() throws {
        // No-op: Types without @Vector fields do nothing
    }

    /// Default implementation of extractRangeBoundary (for types without Range fields)
    ///
    /// This default implementation is used by types that don't use the @Recordable macro
    /// or types that have no Range-type fields. For types with Range fields, the @Recordable
    /// macro generates an optimized implementation.
    ///
    /// This implementation always throws fieldNotFound since the type has no Range fields.
    public static func extractRangeBoundary(
        fieldName: String,
        component: RangeComponent,
        from record: any Recordable
    ) throws -> [any TupleElement] {
        throw RecordLayerError.fieldNotFound(fieldName)
    }

    /// Default implementation: No-op for types without @Spatial fields
    ///
    /// Types with @Spatial attributes will have this method auto-generated
    /// by @Recordable macro with actual validation logic.
    public func validateSpatialFields() throws {
        // No-op: Types without @Spatial fields do nothing
    }
}
