import Foundation
import FoundationDB

// MARK: - PrimaryKeyValue Type Alias

/// Type-erased primary key value
///
/// This associatedtype allows each Recordable type to specify its primary key type.
/// For backward compatibility, it defaults to Tuple.
public typealias DefaultPrimaryKeyValue = Tuple

// MARK: - Recordable Protocol

/// Protocol representing a type that can be persisted as a record
///
/// All record types must conform to this protocol.
/// Typically, the `@Recordable` macro automatically generates conformance to this protocol.
///
/// **Usage Example**:
/// ```swift
/// @Recordable
/// struct User {
///     @PrimaryKey var userID: Int64
///     var email: String
///     var name: String
/// }
/// ```
///
/// **After Macro Expansion**:
/// ```swift
/// extension User: Recordable {
///     static var recordName: String { "User" }
///     static var primaryKeyFields: [String] { ["userID"] }
///     static var allFields: [String] { ["userID", "email", "name"] }
///     // ... other method implementations
/// }
/// ```
public protocol Recordable: Sendable {
    /// Associated type for primary key value
    ///
    /// Defaults to Tuple for backward compatibility.
    /// Override with a specific PrimaryKeyProtocol type for type safety.
    associatedtype PrimaryKeyValue: PrimaryKeyProtocol = Tuple

    /// Record type name (identifier in metadata)
    ///
    /// A name to uniquely identify each record type.
    /// Usually the same as the type name, but can be changed if needed.
    ///
    /// **Examples**: `"User"`, `"Order"`, `"Product"`
    static var recordName: String { get }

    /// List of primary key fields
    ///
    /// A list of field names that constitute the record's primary key.
    /// Can specify a single field or multiple fields (composite primary key).
    ///
    /// **Examples**:
    /// - Single primary key: `["userID"]`
    /// - Composite primary key: `["tenantID", "userID"]`
    static var primaryKeyFields: [String] { get }

    // MARK: - New Type-Safe Primary Key API

    /// Type-safe primary key definition using KeyPaths
    ///
    /// This is the new API for defining primary keys with compile-time safety.
    /// If implemented, it will be used instead of `primaryKeyFields` for:
    /// - Schema definition (Entity.primaryKeyExpression)
    /// - Primary key extraction (via primaryKeyValue)
    ///
    /// **Single field example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<User, String>? {
    ///     PrimaryKeyPaths(keyPath: \.userID, fieldName: "userID")
    /// }
    /// ```
    ///
    /// **Composite key example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<Order, Order.PrimaryKey>? {
    ///     PrimaryKeyPaths(
    ///         extract: { Order.PrimaryKey(tenantID: $0.tenantID, orderID: $0.orderID) },
    ///         fieldNames: ["tenantID", "orderID"]
    ///     )
    /// }
    /// ```
    static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? { get }

    /// Type-safe primary key value
    ///
    /// This property extracts the primary key value using the type specified in
    /// `PrimaryKeyValue` associatedtype. It provides compile-time guarantees that
    /// the extracted value matches the expected type.
    ///
    /// **Example**:
    /// ```swift
    /// var primaryKeyValue: String? { userID }
    /// ```
    var primaryKeyValue: PrimaryKeyValue? { get }

    /// List of all field names (excluding @Transient)
    ///
    /// Names of all fields that will be persisted.
    /// Fields marked with `@Transient` are not included.
    ///
    /// **Example**: `["userID", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index definitions declared with #Index or #Unique macros
    ///
    /// This property should be automatically generated by @Recordable macro
    /// to collect all IndexDefinition static properties declared with #Index/#Unique.
    ///
    /// **Example (generated by macro)**:
    /// ```swift
    /// static var indexDefinitions: [IndexDefinition] {
    ///     [email_index, city__state_index]
    /// }
    /// ```
    ///
    /// If the type doesn't use #Index/#Unique macros, it returns an empty array.
    static var indexDefinitions: [IndexDefinition] { get }

    /// Mapping from field name to Protobuf field number
    ///
    /// Returns the field number used during Protobuf serialization.
    /// If explicitly specified with the `#FieldOrder` macro, that order is used,
    /// otherwise automatically numbered in declaration order.
    ///
    /// - Parameter fieldName: Field name
    /// - Returns: Field number (starting from 1), or nil if not found
    static func fieldNumber(for fieldName: String) -> Int?

    /// Serialize to Protobuf format
    ///
    /// Converts the record to a Protobuf byte sequence.
    /// This implementation is typically auto-generated by macros.
    ///
    /// - Returns: Protobuf byte sequence
    /// - Throws: Serialization error
    func toProtobuf() throws -> Data

    /// Deserialize from Protobuf format
    ///
    /// Restores a record from a Protobuf byte sequence.
    /// This implementation is typically auto-generated by macros.
    ///
    /// - Parameter data: Protobuf byte sequence
    /// - Returns: Restored record
    /// - Throws: Deserialization error
    static func fromProtobuf(_ data: Data) throws -> Self

    /// Extract the value of a specified field (for indexing)
    ///
    /// Used during index construction.
    /// Returns the value corresponding to the field name as an array of `TupleElement`.
    ///
    /// **Examples**:
    /// ```swift
    /// user.extractField("email")  // -> ["alice@example.com"]
    /// user.extractField("tags")   // -> ["swift", "ios", "development"]
    /// ```
    ///
    /// - Parameter fieldName: Field name
    /// - Returns: Array of field values (multiple elements for array-type fields)
    func extractField(_ fieldName: String) -> [any TupleElement]

    /// Extract primary key as Tuple
    ///
    /// Returns the record's primary key in FoundationDB Tuple format.
    /// For a single primary key, it's a 1-element Tuple; for composite keys, it's a multi-element Tuple.
    ///
    /// **Examples**:
    /// ```swift
    /// user.extractPrimaryKey()  // -> Tuple(123)
    /// order.extractPrimaryKey() // -> Tuple("tenant_a", 456)  // Composite key
    /// ```
    ///
    /// - Returns: Primary key Tuple
    func extractPrimaryKey() -> Tuple
}

// MARK: - Helper Extensions

extension Recordable {
    /// Get field name from KeyPath
    ///
    /// **Note**: This implementation is overridden by macros for each type.
    /// The default implementation is a placeholder to prevent compilation errors.
    ///
    /// - Parameter keyPath: KeyPath to the field
    /// - Returns: Field name
    public static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        // This implementation is replaced by macros
        // By default, inferred from KeyPath string representation (with limitations)
        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }

    /// Convert PartialKeyPath to field name string
    ///
    /// This method is used by IndexDefinition to convert KeyPaths to field names.
    public static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        // Try to find a match using the generated fieldName<Value> method
        // by iterating through all fields
        // This is a fallback - the macro-generated implementation is more efficient

        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }
}

// MARK: - Default Implementations (Backward Compatibility)

extension Recordable {
    /// Default implementation: No index definitions
    ///
    /// Types without #Index/#Unique macros return an empty array.
    /// @Recordable macro will override this with actual index definitions.
    public static var indexDefinitions: [IndexDefinition] {
        return []
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, Entity.init() will fall back to building the primary key
    /// expression from `primaryKeyFields`.
    ///
    /// **Migration Path**:
    /// 1. Old API: `primaryKeyFields` + `extractPrimaryKey()` (current)
    /// 2. New API: `primaryKeyPaths` + `primaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? {
        return nil
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, primary key extraction will use `extractPrimaryKey()` instead.
    ///
    /// **Migration Path**:
    /// 1. Old API: `extractPrimaryKey() -> Tuple` (current)
    /// 2. New API: `primaryKeyValue -> PrimaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public var primaryKeyValue: PrimaryKeyValue? {
        return nil
    }
}

// MARK: - Safe Derivation from New API

extension Recordable where PrimaryKeyValue: PrimaryKeyProtocol {
    /// Safely derive primaryKeyFields from primaryKeyPaths
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement primaryKeyFields.
    public static var derivedPrimaryKeyFields: [String] {
        if let paths = primaryKeyPaths {
            return paths.fieldNames
        }
        // Fallback: This should never be called if type implements primaryKeyFields
        fatalError("""
            Type \(Self.self) must implement either:
            1. primaryKeyFields (old API), or
            2. primaryKeyPaths (new API)
            """)
    }

    /// Safely derive extractPrimaryKey from primaryKeyValue
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement extractPrimaryKey().
    public func derivedExtractPrimaryKey() -> Tuple {
        if let value = primaryKeyValue {
            return value.toTuple()
        }
        // Fallback: This should never be called if type implements extractPrimaryKey()
        fatalError("""
            Type \(Self.self) must implement either:
            1. extractPrimaryKey() (old API), or
            2. primaryKeyValue (new API)
            """)
    }
}
