import Foundation
import FoundationDB

// MARK: - PrimaryKeyValue Type Alias

/// Type-erased primary key value
///
/// This associatedtype allows each Recordable type to specify its primary key type.
/// For backward compatibility, it defaults to Tuple.
public typealias DefaultPrimaryKeyValue = Tuple

// MARK: - Recordable Protocol

/// レコードとして永続化可能な型を表すプロトコル
///
/// すべてのレコード型は、このプロトコルに準拠する必要があります。
/// 通常、`@Recordable` マクロがこのプロトコルへの準拠を自動生成します。
///
/// **使用例**:
/// ```swift
/// @Recordable
/// struct User {
///     @PrimaryKey var userID: Int64
///     var email: String
///     var name: String
/// }
/// ```
///
/// **マクロ展開後**:
/// ```swift
/// extension User: Recordable {
///     static var recordName: String { "User" }
///     static var primaryKeyFields: [String] { ["userID"] }
///     static var allFields: [String] { ["userID", "email", "name"] }
///     // ... 他のメソッド実装
/// }
/// ```
public protocol Recordable: Sendable {
    /// Associated type for primary key value
    ///
    /// Defaults to Tuple for backward compatibility.
    /// Override with a specific PrimaryKeyProtocol type for type safety.
    associatedtype PrimaryKeyValue: PrimaryKeyProtocol = Tuple

    /// レコードタイプ名（メタデータでの識別子）
    ///
    /// 各レコード型を一意に識別するための名前です。
    /// 通常は型名と同じですが、必要に応じて変更できます。
    ///
    /// **例**: `"User"`, `"Order"`, `"Product"`
    static var recordName: String { get }

    /// プライマリキーフィールドのリスト
    ///
    /// レコードのプライマリキーを構成するフィールド名のリストです。
    /// 単一フィールドまたは複数フィールド（複合主キー）を指定できます。
    ///
    /// **例**:
    /// - 単一主キー: `["userID"]`
    /// - 複合主キー: `["tenantID", "userID"]`
    static var primaryKeyFields: [String] { get }

    // MARK: - New Type-Safe Primary Key API

    /// Type-safe primary key definition using KeyPaths
    ///
    /// This is the new API for defining primary keys with compile-time safety.
    /// If implemented, it will be used instead of `primaryKeyFields` for:
    /// - Schema definition (Entity.primaryKeyExpression)
    /// - Primary key extraction (via primaryKeyValue)
    ///
    /// **Single field example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<User, String>? {
    ///     PrimaryKeyPaths(keyPath: \.userID, fieldName: "userID")
    /// }
    /// ```
    ///
    /// **Composite key example**:
    /// ```swift
    /// static var primaryKeyPaths: PrimaryKeyPaths<Order, Order.PrimaryKey>? {
    ///     PrimaryKeyPaths(
    ///         extract: { Order.PrimaryKey(tenantID: $0.tenantID, orderID: $0.orderID) },
    ///         fieldNames: ["tenantID", "orderID"]
    ///     )
    /// }
    /// ```
    static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? { get }

    /// Type-safe primary key value
    ///
    /// This property extracts the primary key value using the type specified in
    /// `PrimaryKeyValue` associatedtype. It provides compile-time guarantees that
    /// the extracted value matches the expected type.
    ///
    /// **Example**:
    /// ```swift
    /// var primaryKeyValue: String? { userID }
    /// ```
    var primaryKeyValue: PrimaryKeyValue? { get }

    /// すべてのフィールド名のリスト（@Transient を除く）
    ///
    /// 永続化されるすべてのフィールドの名前です。
    /// `@Transient` でマークされたフィールドは含まれません。
    ///
    /// **例**: `["userID", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index definitions declared with #Index or #Unique macros
    ///
    /// This property should be automatically generated by @Recordable macro
    /// to collect all IndexDefinition static properties declared with #Index/#Unique.
    ///
    /// **Example (generated by macro)**:
    /// ```swift
    /// static var indexDefinitions: [IndexDefinition] {
    ///     [email_index, city__state_index]
    /// }
    /// ```
    ///
    /// If the type doesn't use #Index/#Unique macros, it returns an empty array.
    static var indexDefinitions: [IndexDefinition] { get }

    /// フィールド名からProtobufフィールド番号へのマッピング
    ///
    /// Protobufシリアライズ時に使用されるフィールド番号を返します。
    /// `#FieldOrder` マクロで明示的に指定されている場合はその順序、
    /// そうでない場合は宣言順に自動採番されます。
    ///
    /// - Parameter fieldName: フィールド名
    /// - Returns: フィールド番号（1から開始）、存在しない場合は nil
    static func fieldNumber(for fieldName: String) -> Int?

    /// Protobuf形式にシリアライズ
    ///
    /// レコードをProtobuf形式のバイト列に変換します。
    /// この実装は通常マクロによって自動生成されます。
    ///
    /// - Returns: Protobuf形式のバイト列
    /// - Throws: シリアライズエラー
    func toProtobuf() throws -> Data

    /// Protobuf形式からデシリアライズ
    ///
    /// Protobuf形式のバイト列からレコードを復元します。
    /// この実装は通常マクロによって自動生成されます。
    ///
    /// - Parameter data: Protobuf形式のバイト列
    /// - Returns: 復元されたレコード
    /// - Throws: デシリアライズエラー
    static func fromProtobuf(_ data: Data) throws -> Self

    /// 指定されたフィールドの値を抽出（インデックス用）
    ///
    /// インデックス構築時に使用されます。
    /// フィールド名に対応する値を `TupleElement` の配列として返します。
    ///
    /// **例**:
    /// ```swift
    /// user.extractField("email")  // -> ["alice@example.com"]
    /// user.extractField("tags")   // -> ["swift", "ios", "development"]
    /// ```
    ///
    /// - Parameter fieldName: フィールド名
    /// - Returns: フィールド値の配列（配列型のフィールドの場合は複数要素）
    func extractField(_ fieldName: String) -> [any TupleElement]

    /// プライマリキーをTupleとして抽出
    ///
    /// レコードのプライマリキーを FoundationDB の Tuple 形式で返します。
    /// 単一主キーの場合は1要素、複合主キーの場合は複数要素のTupleになります。
    ///
    /// **例**:
    /// ```swift
    /// user.extractPrimaryKey()  // -> Tuple(123)
    /// order.extractPrimaryKey() // -> Tuple("tenant_a", 456)  // 複合主キー
    /// ```
    ///
    /// - Returns: プライマリキーのTuple
    func extractPrimaryKey() -> Tuple
}

// MARK: - Helper Extensions

extension Recordable {
    /// KeyPathからフィールド名を取得
    ///
    /// **注**: この実装はマクロによって型ごとにオーバーライドされます。
    /// デフォルト実装はコンパイルエラーを防ぐためのプレースホルダーです。
    ///
    /// - Parameter keyPath: フィールドへのKeyPath
    /// - Returns: フィールド名
    public static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        // この実装はマクロによって置き換えられる
        // デフォルトではKeyPathの文字列表現から推測（制限あり）
        let description = "\(keyPath)"

        // KeyPathの文字列表現から最後の要素を取得
        // 例: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }

    /// Convert PartialKeyPath to field name string
    ///
    /// This method is used by IndexDefinition to convert KeyPaths to field names.
    public static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        // Try to find a match using the generated fieldName<Value> method
        // by iterating through all fields
        // This is a fallback - the macro-generated implementation is more efficient

        let description = "\(keyPath)"

        // KeyPathの文字列表現から最後の要素を取得
        // 例: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }
}

// MARK: - Default Implementations (Backward Compatibility)

extension Recordable {
    /// Default implementation: No index definitions
    ///
    /// Types without #Index/#Unique macros return an empty array.
    /// @Recordable macro will override this with actual index definitions.
    public static var indexDefinitions: [IndexDefinition] {
        return []
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, Entity.init() will fall back to building the primary key
    /// expression from `primaryKeyFields`.
    ///
    /// **Migration Path**:
    /// 1. Old API: `primaryKeyFields` + `extractPrimaryKey()` (current)
    /// 2. New API: `primaryKeyPaths` + `primaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public static var primaryKeyPaths: PrimaryKeyPaths<Self, PrimaryKeyValue>? {
        return nil
    }

    /// Default implementation: Returns nil to indicate old API is in use
    ///
    /// When nil, primary key extraction will use `extractPrimaryKey()` instead.
    ///
    /// **Migration Path**:
    /// 1. Old API: `extractPrimaryKey() -> Tuple` (current)
    /// 2. New API: `primaryKeyValue -> PrimaryKeyValue` (future)
    ///
    /// Both APIs will coexist during migration period.
    public var primaryKeyValue: PrimaryKeyValue? {
        return nil
    }
}

// MARK: - Safe Derivation from New API

extension Recordable where PrimaryKeyValue: PrimaryKeyProtocol {
    /// Safely derive primaryKeyFields from primaryKeyPaths
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement primaryKeyFields.
    public static var derivedPrimaryKeyFields: [String] {
        if let paths = primaryKeyPaths {
            return paths.fieldNames
        }
        // Fallback: This should never be called if type implements primaryKeyFields
        fatalError("""
            Type \(Self.self) must implement either:
            1. primaryKeyFields (old API), or
            2. primaryKeyPaths (new API)
            """)
    }

    /// Safely derive extractPrimaryKey from primaryKeyValue
    ///
    /// This default implementation allows types using new API to automatically
    /// satisfy old API requirements without force-unwrapping.
    ///
    /// **Note**: Types using only old API must explicitly implement extractPrimaryKey().
    public func derivedExtractPrimaryKey() -> Tuple {
        if let value = primaryKeyValue {
            return value.toTuple()
        }
        // Fallback: This should never be called if type implements extractPrimaryKey()
        fatalError("""
            Type \(Self.self) must implement either:
            1. extractPrimaryKey() (old API), or
            2. primaryKeyValue (new API)
            """)
    }
}
