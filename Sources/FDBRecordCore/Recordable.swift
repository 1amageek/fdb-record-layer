import Foundation

// MARK: - Recordable Protocol

/// Protocol representing a type that can be persisted as a record
///
/// This is the **FDB-independent** version of Recordable protocol.
/// It contains only metadata and does not depend on FoundationDB types.
///
/// **SSOT (Single Source of Truth)**: This protocol is used by both:
/// - **Client apps** (iOS/macOS): JSON serialization via Codable
/// - **Server apps**: FoundationDB persistence via FDBRecordLayer
///
/// **Usage Example**:
/// ```swift
/// @Recordable
/// struct User {
///     #PrimaryKey<User>([\.userID])
///     #Index<User>([\.email])
///
///     var userID: Int64
///     var email: String
///     var name: String
/// }
///
/// // ✅ Client: JSON serialization
/// let jsonData = try JSONEncoder().encode(user)
///
/// // ✅ Server: FDB persistence
/// try await store.save(user)
/// ```
public protocol Recordable: Sendable, Codable {
    // MARK: - Metadata (FDB-independent)

    /// Record type name (identifier in metadata)
    ///
    /// A name to uniquely identify each record type.
    /// Usually the same as the type name, but can be changed if needed.
    ///
    /// **Examples**: `"User"`, `"Order"`, `"Product"`
    static var recordName: String { get }

    /// List of primary key fields
    ///
    /// A list of field names that constitute the record's primary key.
    /// Can specify a single field or multiple fields (composite primary key).
    ///
    /// **Examples**:
    /// - Single primary key: `["userID"]`
    /// - Composite primary key: `["tenantID", "userID"]`
    static var primaryKeyFields: [String] { get }

    /// List of all field names (excluding @Transient)
    ///
    /// Names of all fields that will be persisted.
    /// Fields marked with `@Transient` are not included.
    ///
    /// **Example**: `["userID", "email", "name", "createdAt"]`
    static var allFields: [String] { get }

    /// Index definitions declared with #Index or #Unique macros
    ///
    /// This property should be automatically generated by @Recordable macro
    /// to collect all IndexDefinition static properties declared with #Index/#Unique.
    ///
    /// **Example (generated by macro)**:
    /// ```swift
    /// static var indexDefinitions: [IndexDefinition] {
    ///     [email_index, city__state_index]
    /// }
    /// ```
    ///
    /// If the type doesn't use #Index/#Unique macros, it returns an empty array.
    static var indexDefinitions: [IndexDefinition] { get }

    /// Mapping from field name to Protobuf field number
    ///
    /// Returns the field number used during Protobuf serialization.
    /// Field numbers are automatically assigned based on declaration order (starting from 1).
    ///
    /// - Parameter fieldName: Field name
    /// - Returns: Field number (starting from 1), or nil if not found
    static func fieldNumber(for fieldName: String) -> Int?

    /// Get enum metadata for a field
    ///
    /// Returns enum type information if the field is a CaseIterable enum.
    /// This method is typically overridden by @Recordable macro for types with enum fields.
    ///
    /// **Default Implementation**:
    /// Returns nil for all fields (no enum metadata available).
    /// @Recordable macro will generate a switch statement that returns metadata
    /// for each enum field.
    ///
    /// **Example (macro-generated)**:
    /// ```swift
    /// static func enumMetadata(for fieldName: String) -> EnumMetadata? {
    ///     switch fieldName {
    ///     case "status":
    ///         return EnumMetadata(
    ///             typeName: "ProductStatus",
    ///             cases: ["active", "inactive", "discontinued"]
    ///         )
    ///     default:
    ///         return nil
    ///     }
    /// }
    /// ```
    ///
    /// - Parameter fieldName: Field name to query
    /// - Returns: EnumMetadata if field is a CaseIterable enum, nil otherwise
    static func enumMetadata(for fieldName: String) -> EnumMetadata?

    /// Get PartialKeyPath for a spatial coordinate field
    ///
    /// Returns a type-erased PartialKeyPath to access spatial coordinate values without using Mirror reflection.
    /// This method is typically implemented by @Recordable macro for types with @Spatial fields.
    ///
    /// **Purpose**: Eliminates Mirror-based reflection in SpatialIndexMaintainer
    /// by providing compile-time type-safe KeyPath accessors via composition.
    ///
    /// **Default Implementation**:
    /// Returns nil for all fields (no spatial coordinate metadata available).
    /// @Recordable macro will generate a switch statement that returns composed PartialKeyPaths
    /// for each @Spatial field's coordinates.
    ///
    /// **Example (macro-generated)**:
    /// ```swift
    /// // For: @Spatial(type: .geo(latitude: \.latitude, longitude: \.longitude, level: 17)) var location: Location
    /// // Macro auto-detects field name "location" and field type "Location"
    /// // Relative KeyPaths: \.latitude, \.longitude (from Location type)
    /// // Composed absolute KeyPaths: \Self.location.latitude, \Self.location.longitude
    ///
    /// static func spatialKeyPath(field: String, coordinate: String) -> PartialKeyPath<Self>? {
    ///     switch (field, coordinate) {
    ///     case ("location", "latitude"): return \Self.location.latitude
    ///     case ("location", "longitude"): return \Self.location.longitude
    ///     default: return nil
    ///     }
    /// }
    /// ```
    ///
    /// **Usage in SpatialIndexMaintainer**:
    /// ```swift
    /// if let partialKeyPath = Record.spatialKeyPath(field: "location", coordinate: "latitude") {
    ///     // Type erasure: cast Any to Double
    ///     let value = record[keyPath: partialKeyPath] as! Double
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - field: Spatial field name (e.g., "location")
    ///   - coordinate: Coordinate name (e.g., "latitude", "longitude", "x", "y", "z")
    /// - Returns: PartialKeyPath to the coordinate value, or nil if not found
    static func spatialKeyPath(field: String, coordinate: String) -> PartialKeyPath<Self>?
}

// MARK: - EnumMetadata

/// Metadata for CaseIterable enum fields
///
/// Stores information about enum types used in Recordable structs.
/// This metadata is used for:
/// - Schema validation
/// - Index definition validation
/// - Protobuf code generation
public struct EnumMetadata: Sendable, Hashable {
    /// Enum type name (e.g., "ProductStatus")
    public let typeName: String

    /// All enum case names in declaration order
    public let cases: [String]

    public init(typeName: String, cases: [String]) {
        self.typeName = typeName
        self.cases = cases
    }
}

// MARK: - Helper Extensions

extension Recordable {
    /// Get field name from KeyPath
    ///
    /// **Note**: This implementation is overridden by macros for each type.
    /// The default implementation is a placeholder to prevent compilation errors.
    ///
    /// - Parameter keyPath: KeyPath to the field
    /// - Returns: Field name
    public static func fieldName<Value>(for keyPath: KeyPath<Self, Value>) -> String {
        // This implementation is replaced by macros
        // By default, inferred from KeyPath string representation (with limitations)
        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }

    /// Default implementation of spatial coordinate accessor
    ///
    /// Returns nil for all fields (no spatial coordinates available).
    /// @Recordable macro will override this for types with @Spatial fields.
    ///
    /// - Parameters:
    ///   - field: Spatial field name
    ///   - coordinate: Coordinate name
    /// - Returns: nil (no spatial metadata by default)
    public static func spatialKeyPath(field: String, coordinate: String) -> PartialKeyPath<Self>? {
        return nil
    }

    /// Convert PartialKeyPath to field name string
    ///
    /// This method is used by IndexDefinition to convert KeyPaths to field names.
    public static func fieldName(for keyPath: PartialKeyPath<Self>) -> String {
        // Try to find a match using the generated fieldName<Value> method
        // by iterating through all fields
        // This is a fallback - the macro-generated implementation is more efficient

        let description = "\(keyPath)"

        // Extract the last component from KeyPath string representation
        // Example: "\MyApp.User.email" -> "email"
        if let lastComponent = description.split(separator: ".").last {
            return String(lastComponent)
        }

        return description
    }
}

// MARK: - Default Implementations

extension Recordable {
    /// Default implementation: No index definitions
    ///
    /// Types without #Index/#Unique macros return an empty array.
    /// @Recordable macro will override this with actual index definitions.
    public static var indexDefinitions: [IndexDefinition] {
        return []
    }

    /// Default implementation: Returns nil for all fields
    ///
    /// @Recordable macro will override this with actual enum metadata.
    public static func enumMetadata(for fieldName: String) -> EnumMetadata? {
        return nil
    }
}

